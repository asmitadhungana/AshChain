npm init

npm install jest@23.6.0 --save-dev

cat package.json =>to see the package.json to check if the package has actually been installed

SHA-256 => 256 for bits(0's and 1's) of hash
        => equal to 64 Hexadecimal characters (0-9 and A-F)
        =>produces a unique value for unique input
        => A one-way function(data -> hash)
        =>[encryption is easy but decryption(hash -> data) is next to impossible]

Proof of work in blockchain:
Bitcoin: inspired by a system called HashCash(1997) 

HashCash => originally developed to prevent the problem of email spamming
    => any any point, there's going to be a level of difficulty in the system
    =>depending upon this diff, one miner shall add a new block
    =>they'll have to find a hash value for this block that matches the difficulty 
    =>for matching, miners will have to find the same number of leading zeros as the current difficulty for the generated hash of the new block to add to the chain

    =>becomes exponentially harder as the diff increases

    =>nonce comes in play

    =>generate new hashes by changing nonce values
    =>takes decent amt of computational work

    =>Thus, finding the nonce that unlocks a hash that meets the difficulty requirement is that very proof of work

    NONCE: Number Used Once

    NOTE: We're using Hexadecimal form of SHA-256 {rep in 64 characters}
    BITCOIN uses BINARY form of the hash (rep in 256 binary(0 and 1) characters)

    DIFFICULTY : no of leading 0 BITS(Binary format ma) in a 256 bit binary string

    O=0 Once a miner has succesfully mined a block (found the correct nonce value), s/he has the rights to submit their block with the correctfound nonce value to other miners

    0-0 Then the other miners can quickly verify the valid block and then add it to their own chain w/o having to redo the same computational work

    Bitcoin adds a new block to the chain in every 10 minutes

    =>> 51% attack : when a evil miner has 51% of the computational power of the whole blockchain ntk

    =>> impossible because it COSTS TOO MUCH!
    => as of the EOY 2018, it would cost more than $9 Billion to take over the entire ntk with 51% attack

WE've:
    => implemented Proof of work
    => set dynamic difficulty and Mine Rate
        [to adjust the blockchain diff level in order to bring the average rate of blocks being added mined closer to as set mining rate]
    => by adding a diff attribute to each block
    => in addition to this we've introduced a global time-value called the MINE_RATE
    => MINE_RATE: reps the rate at which we want a block to be added to the chain

>DIFFICULTY ADUSTMENT:
=> check the timestamp of the new block which is being  mined
=> compare it's timestamp with the last block
=> calculate the diff btn the two timestamps
=> if diff < MINE_RATE => the block was mined too quickly
                       => So, raise the difficulty for the  next block by 1
=> if diff > MINE_RATE => the block was mined too slowly
                       => So, lower the diff by 1       
=>THIS WAY, We'll always ADJUST the difficulty

key diff btn Bitcoin's DIFFICULTY sys and ours:
=>Bitcoin checks for leading zer0's in 256 binary bits hash
=> Our sys checks it on 64 characters Hexadecimal hash

INSTALL: npm i hex-to-binary@1.0.1 --save

==> WHICH WE CHANGED TO CHECK FOR BINARY HASHES (using hex-to-binary node module we added)

TROUBLE encountered: due to dynamic difficulty setting, our system was vulnerable to hacker attacks to reset it according to them

SOVED: => in isValidChain() mthd in `blockchain.js`, make a rule to make sure that the difficulty never adjusts by more than 1 for every adjacent blocks
     
Part 4: BLOCKCHAIN API

=> Read the blockchain
=> write to the blockchain

INSTALL API: EXPRESS ()
                        npm i express@4.16.3 --save

will serve 2 main purposes:
    => allow a frontned application to interact w/ the blockchain in order to read data abt the blockchain and also write data to the blockchain
    => allow other blockchain backends to interact w/ each other

We'll configure EXPRESS server to access various HTTP requests that'll be made over the web

HTTP REQUESTS:
    GET=> associated w/ reading data [to read the blocks of the blockchain]
    POST => w/ sending data to the web server [to carry data to add new block to the chain consisting of that data]

    GET:
    //.get takes 2 instances("endpoint_on_the_server_where_we_want_this_req_to_be_located" ,   a_callback_fxn_which_aill_fire_when_this_get_req_is_used(request, response)=>{})
    //res object allows us to define how we want this get request to respond 

    POST: same as above
    receives data from the user in json format


Blockchain instances in the ntk=> can read each other's data and add new blocks to the chains if necessary

ADDED: index.js file
NOTE: in package.json, add a script: "start":"node index.js"

COMMAND: npm run start
INSTALL: npm i nodemon@1.18.4 --save-dev
NOTE: in package.json, add a script: "dev":"nodemon index.js"

INSTALL : npm i body-parser@1.18.3 --save

Networking pattern used: PubSub [vd: 5.4]

    PubSub=> Real-Time Messaging ntk 
        => To  broadcast updates of a local bc to all the peers of the ntk
        => Reduces a lot of work needed for alternative ntk implementations like "Tracking Socket Addresses" [often used in peer-peer ntks]
        Tracking Socket Address:
        =>In this ntk implementation, realtime socket cnnxns are open btn servers and each server has to maintain a list of peers it's made a connection with.
        =>Whenever a msg broadcast needs to happen in the entire ntk btn all peers, that node needs to send a direct msg to every single peer that has kept track of in its list.
        => It's a lot of work
    
    Blockchain Pub/Sub [ntk implementation used here]

PubNub: used for this [vd: 5.9]

$ npm i pubnub@4.21.6 â€”save

=>make pubsub.js
=> write code in it
=> make an instance of it in index.js

goto pubnub.com => login using dhun... gmail => create a new app => click on it=> get the keys => use it in pubsub.js

=> For: Start Peers and Broadcast Chain on API Mine
INSTALL Module: Cross-environment [vd: 5.11]
$ npm i cross-env@5.2.0 --save-dev
    ADD to package.json :"dev-peer" : "cross-env GENERATE_PEER_PORT='true' nodemon index.js"

    =>helps us to set environment variables programmatically no matter what OS or Cmd Line Appn one is using
    => develop precisely nodejs appns to work w/ environment variables no matter what machine one's using

    =>to start and GENERATE PEER PORT command: npm run dev-peer 

TASK: SYNC CHAINS on CONNECT

INSTALL MODULE: request
$ npm i request@2.88.0 --save

    => gives us a fxn has the ability to send a http get request

import it in index.js and use it

ERROR: vd: 5.12




